{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexports.__esModule = true;\nexports.default = prepareDestination;\n\nvar _querystring = require(\"./querystring\");\n\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\n\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction prepareDestination(destination, params, query, appendParamsToQuery, basePath) {\n  let parsedDestination = {};\n\n  if (destination.startsWith('/')) {\n    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href\n    } = new URL(destination);\n    parsedDestination = {\n      pathname,\n      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href\n    };\n  }\n\n  const destQuery = parsedDestination.query;\n  const destPath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n  const destPathParamKeys = [];\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);\n  const destPathParams = destPathParamKeys.map(key => key.name);\n  let destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  let newUrl; // update any params in query values\n\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;\n\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`;\n      const queryCompiler = pathToRegexp.compile(value, {\n        validate: false\n      });\n      value = queryCompiler(params).substr(1);\n    }\n\n    destQuery[key] = value;\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n\n\n  const paramKeys = Object.keys(params);\n\n  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key];\n      }\n    }\n  }\n\n  const shouldAddBasePath = destination.startsWith('/') && basePath;\n\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(params)}`;\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`);\n    }\n\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n\n\n  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);\n  return {\n    newUrl,\n    parsedDestination\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["parsedDestination","destination","query","destQuery","destPath","pathname","destPathParamKeys","pathToRegexp","destPathParams","key","destinationCompiler","validate","Object","value","Array","strOrArray","queryCompiler","paramKeys","appendParamsToQuery","params","shouldAddBasePath","newUrl","hash","err"],"mappings":"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","sourcesContent":["import { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\ntype Params = { [param: string]: any }\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean,\n  basePath: string\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`\n      const queryCompiler = pathToRegexp.compile(value, { validate: false })\n      value = queryCompiler(params).substr(1)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  const paramKeys = Object.keys(params)\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  const shouldAddBasePath = destination.startsWith('/') && basePath\n\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(\n      params\n    )}`\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete parsedDestination.search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}